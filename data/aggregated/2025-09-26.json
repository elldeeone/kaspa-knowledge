{
  "date": "2025-09-26",
  "generated_at": "2025-09-26T03:17:36.077691",
  "sources": {
    "medium_articles": [],
    "telegram_messages": [],
    "github_activities": [],
    "discord_messages": [],
    "forum_posts": [
      {
        "post_id": 688,
        "post_number": 2,
        "topic_id": 411,
        "topic_title": "Pruning safety in the vProgs architecture",
        "topic_slug": "pruning-safety-in-the-vprogs-architecture",
        "content": "In practice, your model turns “old history” into “recent proof obligations.” Any transaction that would otherwise fail because its scope dips below the pruning point can succeed by anchoring its logic to a recent zk proof of the account instead. The trade-off is larger proofs/witnesses, but much smaller storage requirements for nodes. Example 1: Smart Contract with Old Transaction History Suppose account A deployed a VProg (like a simple token contract) 10,000 blocks ago. A new transaction x wants to read some intermediate balance changes that happened 9,500 blocks ago (well below the pruning horizon). Without your pruning model: Node tries to fetch the old transaction data. If it’s pruned, the scope fails → transaction breaks. With your pruning model: Instead of reading the ancient balance updates, x can be reformulated as x′. Provide witnesses from a more recent proof of A’s account state (e.g., a zk proof that the balance at block 9,800 already incorporates the old events). Result: The node only needs to check recent proofs (within Δ=500 blocks), not store the whole 10,000-block history. Example 2: Batch Payment Program A VProg batches 1,000 payments into small chunks. Some of those payments touch states 600 rounds old. By the Δ=500 rule, those old vertices are discarded. How it works: Instead of providing witnesses for the ancient payment states, the transaction provides a witness to the account’s latest zk proof (say round 9,950). The computation scope shrinks to the last Δ blocks, and the proof shows that all prior history is “absorbed” into the proven account state. Example 3: DeFi Program with Reuse of Scopes A lending VProg frequently rebuilds transaction scopes (e.g., when users roll over loans). A scope references a state 400 blocks back. A zk proof for that account was just refreshed 10 blocks ago. Your Γ safeguard kicks in: Because that vertex was “recently read,” it isn’t pruned for another Γ=50 rounds. When the loan rollover transaction arrives, it can still reference that intermediate state without being forced to re-supply a long witness. Example 4: Cold Account Wakes Up Account B hasn’t been active in months. Its old vertices are far below pruning. A new transaction wants to interact with B’s state. With your model: Transaction provides a zk proof for B’s state at a recent pruning boundary (e.g., “as of block 1,000,000, B had balance 50”). No need to replay months of transactions — just prove membership of that final state. Node discards all of B’s old vertices once Δ is exceeded. VProg Scope with Pruning: Substitute Recent Proof vprog_pruning_delta_gamma2000×1200 56.3 KB Top: Tx depends on pruned old state → breaks. Bottom: Tx uses a recent zk proof inside the pruning window → succeeds. Δ / Γ Discard Rules for Vertices vprog_pruning_example2000×1200 64.9 KB Top: Discard vertices older than Δ rounds once a new proof exists. Bottom: If a vertex was recently read, preserve it temporarily for Γ rounds.",
        "raw_content": "",
        "author": "Gordon_Murray",
        "created_at": "2025-09-26T01:05:23.335Z",
        "updated_at": "2025-09-26T01:10:08.942Z",
        "reply_count": 0,
        "url": "https://research.kas.pa/t/pruning-safety-in-the-vprogs-architecture/411/2",
        "category_id": 11
      }
    ],
    "news_articles": [],
    "onchain_data": {},
    "documentation": []
  },
  "metadata": {
    "total_items": 1,
    "sources_processed": [
      "forum: 1 items"
    ],
    "resource_usage": {
      "peak_memory_gb": 0.014556884765625,
      "memory_status": "OK",
      "disk_status": "OK",
      "processing_time": 0.002176046371459961
    }
  }
}