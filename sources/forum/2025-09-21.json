{
  "date": "2025-09-21",
  "generated_at": "2025-09-22T03:21:24.781794+00:00",
  "source": "discourse_forum",
  "status": "success",
  "forum_posts": [
    {
      "post_id": 681,
      "post_number": 1,
      "topic_id": 429,
      "topic_title": "Random Linear Network Coding For Scalable BlockDAG",
      "topic_slug": "random-linear-network-coding-for-scalable-blockdag",
      "content": "About Me I\u2019m Gordon Murray, an independent researcher in the Kaspa community. My work focuses on improving Kaspa\u2019s networking layer, including publishing a whitepaper on RLNC for BlockDAG propagation LinkeIn link. This post is a condensed version of that research, with additional ideas about enabling Kaspa to run over wireless mesh networks. The whitepaper was highlighted on my LinkedIn by Gilad Aviram, who encouraged me to share it here for discussion at the request of Michael Sutton. I should also note that I\u2019ve been inspired by the pioneering work of Muriel M\u00e9dard on network coding and the Optimum P2P project, which demonstrated RLNC\u2019s real-world benefits in Ethereum. Proposal: Applying Random Linear Network Coding (RLNC) to Kaspa\u2019s P2P Layer (Including Wireless Mesh Networks) Executive Summary Kaspa\u2019s BlockDAG currently achieves ~10 blocks per second (BPS) and aims for 100+ BPS. While consensus (GHOSTDAG) is efficient, the network layer remains a bottleneck: \u2022 Redundant gossip floods overlapping transactions. \u2022 Multiple block bodies per second stress bandwidth. \u2022 Global latency skew reduces blue-set inclusion fairness. I propose integrating Random Linear Network Coding (RLNC) into Kaspa\u2019s P2P layer. RLNC optimizes propagation by transmitting linear combinations of blocks/transactions, so nearly every received shard is innovative. This directly benefits: \u2022 Block propagation (reduces redundancy) \u2022 IBD (Initial Block Download) (faster sync, fewer stalls) \u2022 Mempool sync (efficient transaction relay) \u2022 And critically, enables Kaspa to run over wireless mesh networks for maximum decentralization. Layer Separation: RLNC is Consensus-Agnostic \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Application Layer \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Consensus Layer \u2502 \u2502 (Kaspa PoW: Mining + GHOSTDAG) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Network / P2P Layer \u2502 \u2502 \u2190 RLNC OPERATES HERE \u2192 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Transport Layer \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 RLNC optimizes the network layer. Consensus remains untouched: whether PoW or PoS, blocks must still propagate efficiently. Current P2P Implementation (Rusty-Kaspa) In kaspad/src/p2p/flows: \u2022 Block relay \u2192 flows/block/handle_incoming.rs \u2022 Transaction relay \u2192 flows/transaction/relay.rs \u2022 Initial Block Download \u2192 flows/ibd All rely on gossip-based flooding: every block or transaction is propagated individually. This ensures delivery, but at high BPS causes: Redundant transmission of overlapping transactions. Bandwidth stress from concurrent block bodies. Latency skew \u2192 slower blocks earn less blue score, reducing fairness. RLNC Benefits for Kaspa 1. Block Propagation \u2022 Encode multiple concurrent blocks into shards. \u2022 Peers forward different shards \u2192 receivers decode originals once rank is full. \u2022 Reduces redundant gossip. 2. IBD (Initial Block Download) \u2022 Sync peers send coded shards over block ranges. \u2022 New nodes don\u2019t stall on missing blocks. \u2022 Faster historical sync. 3. Transaction Relay \u2022 Batch encode mempool transactions. \u2022 Even if wireless peers miss shards, decoding succeeds once enough arrive. Kaspa over Wireless Mesh Networks Why RLNC is Ideal for Mesh Wireless mesh networks are lossy, variable-latency, and retransmission-expensive. RLNC was originally developed for these conditions (multicast, satellite, ad-hoc). Mesh-Specific Benefits \u2022 Multicast efficiency \u2192 one radio transmission helps multiple neighbors. \u2022 Partition healing \u2192 shards rapidly fill in missing data after splits. \u2022 Resilience \u2192 innovative shards survive packet loss. \u2022 Energy efficiency \u2192 fewer retransmissions save battery-powered nodes. To our knowledge, no high-throughput PoW BlockDAG has ever been adapted to wireless mesh. Prior experiments used Hyperledger Fabric or PoA Ethereum with low block rates. Kaspa + RLNC would be the first truly high-rate permissionless blockchain optimized for mesh networks. Example: RLNC in Rusty-Kaspa // protocol/src/messages/rlnc.rs #[derive(Clone, Debug, Serialize, Deserialize)] pub struct RlncShard { pub coefficients: Vec<u8>, // Random GF(2^8) coefficients pub payload: Vec<u8>, // Encoded block/tx data pub commitments: Vec<Hash>, // Merkle roots for integrity } Extend block relay (flows/block): fn propagate_blocks_rlnc(blocks: Vec<Block>) { let shards = rlnc::encode(blocks, redundancy_factor); for (peer, shard) in peers.iter().zip(shards) { send_message(peer, Message::RlncShard(shard)); } } On receiving side: fn handle_rlnc_shard(shard: RlncShard) { decoder.add_shard(shard); if decoder.is_ready() { let blocks = decoder.decode(); for block in blocks { validate_and_insert(block); // consensus unchanged } } } Quantitative Outlook (Whitepaper Results) Formal model: RLNC improves finality when 3(1\u2212\u03b7)\u03c4 > \u03b4 where: \u2022 \u03b7 = efficiency factor (bandwidth savings) \u2022 \u03c4 = network mixing time \u2022 \u03b4 = decode overhead Example from whitepaper: \u2022 With W=10 blocks, \u03c1=0.6 overlap \u2192 \u03b7 \u2248 0.46 (54% savings). \u2022 \u03c4 \u2248 80ms \u2192 RLNC can tolerate \u03b4 up to ~130ms. \u2022 Optimized decoding achieves \u03b4 < 5ms. Thus RLNC yields 40\u201360% bandwidth savings and reduced ordering lag, improving blue-set fairness. Deployment Strategy Phase I: Systematic RLNC for block bodies (send some uncoded chunks + coded shards). Phase II: Transaction batch gossip. Phase III: Multi-tip coding across sliding windows. Phase IV: Test with simpa under lossy/mesh conditions. Phase V: Opt-in rollout (--enable-rlnc). This roadmap is backward-compatible and can begin in private relay overlays before public deployment. Conclusion RLNC directly addresses Kaspa\u2019s network bottlenecks: \u2022 Reduces redundant gossip traffic. \u2022 Speeds up IBD and transaction relay. \u2022 Improves blue-set inclusion fairness at high BPS. \u2022 Enables Kaspa to run over wireless mesh networks, maximizing decentralization. Bottom Line: RLNC is not just a bandwidth optimization \u2014 it is a novel enabler that could make Kaspa the first high-throughput PoW BlockDAG blockchain to run efficiently on mesh networks. Call to Action I invite Kaspa devs and researchers to: Review the proposed RlncShard message type and relay flow. Use simpa with lossy network parameters to emulate mesh conditions. Discuss feasibility, trade-offs, and next steps. With RLNC, Kaspa can scale not just in datacenters but across community-built mesh deployments, making it censorship-resistant, resilient, and globally distributed.",
      "raw_content": "",
      "author": "Gordon_Murray",
      "created_at": "2025-09-21T11:56:08.957Z",
      "updated_at": "2025-09-21T11:56:08.957Z",
      "reply_count": 0,
      "url": "https://research.kas.pa/t/random-linear-network-coding-for-scalable-blockdag/429/1",
      "category_id": 1
    }
  ],
  "metadata": {
    "forums_processed": 1,
    "total_posts_fetched": 1,
    "credential_status": "configured",
    "processing_mode": "topic_centric"
  }
}