{
  "date": "2025-09-26",
  "generated_at": "2025-09-26T03:17:35.993831+00:00",
  "source": "discourse_forum",
  "status": "success",
  "forum_posts": [
    {
      "post_id": 688,
      "post_number": 2,
      "topic_id": 411,
      "topic_title": "Pruning safety in the vProgs architecture",
      "topic_slug": "pruning-safety-in-the-vprogs-architecture",
      "content": "In practice, your model turns \u201cold history\u201d into \u201crecent proof obligations.\u201d Any transaction that would otherwise fail because its scope dips below the pruning point can succeed by anchoring its logic to a recent zk proof of the account instead. The trade-off is larger proofs/witnesses, but much smaller storage requirements for nodes. Example 1: Smart Contract with Old Transaction History Suppose account A deployed a VProg (like a simple token contract) 10,000 blocks ago. A new transaction x wants to read some intermediate balance changes that happened 9,500 blocks ago (well below the pruning horizon). Without your pruning model: Node tries to fetch the old transaction data. If it\u2019s pruned, the scope fails \u2192 transaction breaks. With your pruning model: Instead of reading the ancient balance updates, x can be reformulated as x\u2032. Provide witnesses from a more recent proof of A\u2019s account state (e.g., a zk proof that the balance at block 9,800 already incorporates the old events). Result: The node only needs to check recent proofs (within \u0394=500 blocks), not store the whole 10,000-block history. Example 2: Batch Payment Program A VProg batches 1,000 payments into small chunks. Some of those payments touch states 600 rounds old. By the \u0394=500 rule, those old vertices are discarded. How it works: Instead of providing witnesses for the ancient payment states, the transaction provides a witness to the account\u2019s latest zk proof (say round 9,950). The computation scope shrinks to the last \u0394 blocks, and the proof shows that all prior history is \u201cabsorbed\u201d into the proven account state. Example 3: DeFi Program with Reuse of Scopes A lending VProg frequently rebuilds transaction scopes (e.g., when users roll over loans). A scope references a state 400 blocks back. A zk proof for that account was just refreshed 10 blocks ago. Your \u0393 safeguard kicks in: Because that vertex was \u201crecently read,\u201d it isn\u2019t pruned for another \u0393=50 rounds. When the loan rollover transaction arrives, it can still reference that intermediate state without being forced to re-supply a long witness. Example 4: Cold Account Wakes Up Account B hasn\u2019t been active in months. Its old vertices are far below pruning. A new transaction wants to interact with B\u2019s state. With your model: Transaction provides a zk proof for B\u2019s state at a recent pruning boundary (e.g., \u201cas of block 1,000,000, B had balance 50\u201d). No need to replay months of transactions \u2014 just prove membership of that final state. Node discards all of B\u2019s old vertices once \u0394 is exceeded. VProg Scope with Pruning: Substitute Recent Proof vprog_pruning_delta_gamma2000\u00d71200 56.3 KB Top: Tx depends on pruned old state \u2192 breaks. Bottom: Tx uses a recent zk proof inside the pruning window \u2192 succeeds. \u0394 / \u0393 Discard Rules for Vertices vprog_pruning_example2000\u00d71200 64.9 KB Top: Discard vertices older than \u0394 rounds once a new proof exists. Bottom: If a vertex was recently read, preserve it temporarily for \u0393 rounds.",
      "raw_content": "",
      "author": "Gordon_Murray",
      "created_at": "2025-09-26T01:05:23.335Z",
      "updated_at": "2025-09-26T01:10:08.942Z",
      "reply_count": 0,
      "url": "https://research.kas.pa/t/pruning-safety-in-the-vprogs-architecture/411/2",
      "category_id": 11
    }
  ],
  "metadata": {
    "forums_processed": 1,
    "total_posts_fetched": 1,
    "credential_status": "configured",
    "processing_mode": "topic_centric"
  }
}