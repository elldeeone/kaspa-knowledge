{
  "date": "2025-08-17",
  "generated_at": "2025-08-18T04:00:25.547393+00:00",
  "source": "discourse_forum",
  "status": "success",
  "forum_posts": [
    {
      "post_id": 641,
      "post_number": 1,
      "topic_id": 407,
      "topic_title": "Zoom-in: A formal backbone model for the vProg computation DAG",
      "topic_slug": "zoom-in-a-formal-backbone-model-for-the-vprog-computation-dag",
      "content": "Context/broader-outlook: vprog proposal. The following presents a minimal formal model for the computational cost of synchronous composability for verifiable programs (vProgs) operating on a shared sequencer. The model defines a \u201ccomputational scope\u201d\u2014the historical dependency subgraph a vProg must execute to validate a new transaction. The model shows that frequent zero-knowledge proof (ZKP) submissions act as a history compression mechanism, reducing this scope and thereby the cost of cross-vProg interaction. 1. The Model Consider a system of vProgs interacting through a global, ordered sequence of operations. vProg & Accounts: A verifiable program, p, is a state transition function combined with a set of accounts it exclusively owns, S_p. Only p has write-access to any account a \\in S_p. Operation sequence (T): The system\u2019s evolution is defined by a global sequence of operations, T = \\langle op_1, op_2, \\dots \\rangle, provided by a shared sequencer. An operation is either a Transaction (x) or a ZK-Proof Submission (z). Transaction (x): An operation describing an intended state transition. It is defined by a tuple containing: r(x): The declared read-set of account IDs. w(x): The write-set of account IDs, with the constraint that w(x) \\subseteq r(x). \\pi(x): The witness set. A (potentially empty) set of witnesses, where each proves the state of an account a at a specific time t'. These are provided to resolve the transaction\u2019s dependency scope and are independent of the direct read-set r(x). ZK-Proof submission & state commitments: A proof object, z_p^i, submitted by vProg p, attests to the validity of its state transitions up to a time t. It contains a state commitment, C_p^t. Structure: This commitment C_p^t is a Merkle root over the sequence of per-step state roots created by p since its last proof z_p^{i-1} (e.g., from time j to t=j+k). Implication: This hierarchical structure is crucial because it allows for the creation of concise witnesses for the state of any account owned by p at any intermediate time between proof submissions. Execution rule: Any vProg p that owns an account in w(x) must execute transaction x. Remark on composability: This execution rule enables two primary forms of composable transactions: Single-writer composability: The write-set w(x) is owned by a single vProg, but the read-set r(x) includes accounts from other vProgs. Multi-writer composability: The write-set w(x) contains accounts owned by two or more vProgs. This implies a more complex interaction, such as a cross-vProg function call, and requires all owning vProgs to execute the transaction per the rule above. 2. The Computation DAG The flow of state dependencies is modeled using a Computation DAG G = (V, E), whose structure is determined dynamically by the global sequence of transaction declarations. Vertices (V): A vertex v = (a, t) represents the state of account a at time t. The state data for a vertex is not computed globally; instead, it is computed and stored locally by a vProg only when required by a scope execution. Edges (E): The set E contains the system\u2019s transactions. Each transaction x_t acts as a hyperedge, connecting a set of input vertices (its reads) to a set of output vertices (its writes). Graph construction: When a transaction x_t appears in the sequence: New vertices are created for each account in its write-set, \\{v_{a, t} \\mid a \\in w(x_t)\\}. The transaction x_t itself is added to E, forming a dependency from the set of vertices it reads from to the set of new vertices it creates. State compression: When a proof z_p^i appears in the sequence, it logically compresses the dependency history for all accounts in S_p. This creates a new, trustless anchor point in the DAG that other vProgs can reference. The historical vertices are now considered eligible for physical deletion by nodes after a safe time delay. Remark on the write-set constraint: The rule w(x) \\subseteq r(x), defined earlier, is enforced to ensure the DAG\u2019s structure is independent of execution outcomes. If a transaction contains a conditional write to an account a_w \\in w(x) that fails, the new vertex v_{a_w, t} must still be populated with a valid state. By requiring a_w to also be in the read-set r(x), we guarantee that the prior state of a_w is available to be carried forward. 3. Computational Scope The scope is the set of historical transactions a vProg must re-execute to validate a new transaction, x_t. Read vertices (R(x_t)): The dynamic set of graph vertices that the transaction\u2019s declared read-set, r(x), resolves to at time t. For each account a \\in r(x), this corresponds to the vertex v_{a,k} with the largest timestamp k < t. Anchor set (A(p, x_t)): The set of vertices that serve as terminal points for the dependency traversal. For a vProg p executing x_t, this set includes: All vertices whose state is proven by a witness in \\pi(x_t). All vertices for which p has already computed and stored the state data from a previous scope execution. Scope definition: The scope is the entire dependency history of the transaction\u2019s inputs, minus the history already covered by the anchors: \\text{Scope}(p, x_t) = \\text{Past}(R(x_t)) \\setminus \\text{Past}(A(p, x_t)) Where Past(V') is the set of transaction-edges on paths in G leading to any vertex in the set V'. Remark on witnesses and anchor time: Unaligned proof submissions can create \u201calternating\u201d dependencies. The hierarchical state commitment structure solves this by allowing a transaction issuer to choose a single, globally consistent witness anchor time, t_{anchor}, for all provided witnesses. This transforms the starting point for the scope computation from a jagged edge into a clean, straight line, simplifying the scope to the DAG segment between t_{anchor} and t. Core Contributions This model provides a formal ground for several key properties of the proposed architecture, centered on sovereignty, scalability, and the emergence of a shared economy. First, the model provides a formalization of vProg sovereignty. Despite the shared environment, vProgs retain full autonomy. Liveness sovereignty is guaranteed because a vProg\u2019s ability to execute and prove its own state is never contingent on the cooperation of its peers. Furthermore, resource sovereignty is provided by the Scope function, which allows a vProg to price the computational load of any transaction and protect itself from denial-of-service attacks. Second, the model provides a rigorous framework for analyzing computational efficiency and scalability, which is detailed in the following section. The key insight is that system-wide performance exhibits a sharp phase transition that can be managed by tuning the proof frequency to prevent the formation of a giant dependency component. Finally, the Scope cost function serves as a primitive for a shared economy. It creates a positive-sum game of \u201cdependency elimination,\u201d where self-interested vProgs are incentivized to compress their history, making them cheaper dependencies for the entire ecosystem. It also provides a foundation for sophisticated economic mechanisms like scope-cost sharing or Continuous Account Dependency (CAD). Scalability and Phase Transitions System-wide performance is a direct function of the proof epoch length, F, which we define as the number of transactions between consecutive proof submissions. Assuming a globally coordinated proof frequency for simplicity, the total computational overhead does not degrade linearly but exhibits a sharp phase transition. This means efficiency is maintained by keeping the proof epoch length sufficiently short. The dependency entanglement within an epoch can be analyzed by reducing the timed computation DAG to a timeless, undirected graph G'_F, where vertices are accounts and an edge connects any two accounts that interact within a transaction. In this reduced graph, the size of the largest connected component serves as a proxy for the maximum aggregate scope a single vProg might need to compute. The formation of this graph can be modeled using the well-known Erd\u0151s\u2013R\u00e9nyi random graph model. Let N be the total number of accounts and q be the probability of a cross-vProg transaction. A classic result for random graphs is the existence of a sharp phase transition: a \u201cgiant component\u201d emerges if the edge probability p (proportional to Fq/N^2) exceeds the critical threshold of 1/N. To avoid this, the epoch length must be kept below this threshold, approximately F < N/q. For any F below this value, the largest dependency clusters are small, on the order of O(\\log N). This result implies that the computational overhead becomes manageable. Instead of the worst-case scenario where a vProg re-executes the entire epoch\u2019s history\u2014a cost of O(nC), where n is the number of vProgs and C is the ideal cost\u2014the work for an average vProg is the cost of executing its own transactions, plus a small, logarithmically-sized fraction of other transactions. While real-world transaction patterns may be non-uniform, similar critical threshold phenomena are known to exist in more complex models like power-law graphs. The key insight remains: the model provides a formal basis for managing system-wide efficiency by tuning the proof epoch length F to stay within a region that prevents the formation of a giant dependency component. This efficiency mechanism is the foundation for the positive-sum game described earlier. Self-interested vProgs are incentivized to compress their history frequently, as doing so makes them cheaper and more attractive dependencies for the entire ecosystem. This economic pressure helps justify our initial simplifying assumption of a global proof epoch, as vProgs that fail to keep pace will effectively be excluded from composable interactions due to their high cost.",
      "raw_content": "",
      "author": "michaelsutton",
      "created_at": "2025-08-17T12:27:35.400Z",
      "updated_at": "2025-08-17T16:59:48.598Z",
      "reply_count": 0,
      "url": "https://research.kas.pa/t/zoom-in-a-formal-backbone-model-for-the-vprog-computation-dag/407/1",
      "category_id": 11
    },
    {
      "post_id": 642,
      "post_number": 2,
      "topic_id": 407,
      "topic_title": "Zoom-in: A formal backbone model for the vProg computation DAG",
      "topic_slug": "zoom-in-a-formal-backbone-model-for-the-vprog-computation-dag",
      "content": "Nice writeup! Pls provide example explaining how defining scope as Past(R(x_t)) minus Past(p_{t-1}) does not hold. I\u2019m using p_t as notation for the past of the prog\u2019s state at time {t-1}",
      "raw_content": "",
      "author": "hashdag",
      "created_at": "2025-08-17T12:56:48.038Z",
      "updated_at": "2025-08-17T12:57:07.421Z",
      "reply_count": 1,
      "url": "https://research.kas.pa/t/zoom-in-a-formal-backbone-model-for-the-vprog-computation-dag/407/2",
      "category_id": 11
    },
    {
      "post_id": 643,
      "post_number": 3,
      "topic_id": 407,
      "topic_title": "Zoom-in: A formal backbone model for the vProg computation DAG",
      "topic_slug": "zoom-in-a-formal-backbone-model-for-the-vprog-computation-dag",
      "content": "hashdag: Pls provide example explaining how defining scope as Past(R(x_t)) \\setminus Past(p_{t-1}) does not hold. I\u2019m using p_{t-1} as notation for the past of the prog\u2019s state at time {t-1} There are two arguments as to why the pure past diff Past(R(x_t)) \\setminus Past(p_{t-1}) does not suffice (related to the two terms in the anchor set). witnesses provided by the txn can cut the past diff thus reducing the scope size (ie a witness can be provided to a point way above Past(p_{t-1})) precisely because of the case above, being within Past(p_{t}) does not mean the transaction was actually computed by the prog, hence state data might be locally unknown for some vertices in this past (think of transactions within the past diff at time t but below the aforementioned cut). The following case illustrates both points: Prog p owns account A. Accounts B, C are foreign A_{t-5} is the maximal vertex for account A at time t-1 Txn x_t reads from B_{t-1}, A_{t-5} and writes to A_t. It provides a witness directly to B_{t-1} Txn x_{t-1} read from B_{t-3} and wrote to B_{t-1} Txn x_{t-2} read from B_{t-3} and wrote to C_{t-2} Txn x_{t-3} read from B_{t-4} and wrote to B_{t-3} Txn x_{t+1} reads from C_{t-2} and writes to A_{t+1}. It provides a witness to B_{t-4}. At time t, a witness was provided to B_{t-1}, so txns x_{t-2}, x_{t-3} were not executed by p, but entered its past. At time t+1, a witness is provided to B_{t-4}, so p will need to execute x_{t-3}, x_{t-2} in order to compute C_{t-2} (despite being in its past already). image1280\u00d7713 70.1 KB Edit: B_{t-1} should be technically named B_{t-2} to follow the correct indexing convention.",
      "raw_content": "",
      "author": "michaelsutton",
      "created_at": "2025-08-17T14:22:47.714Z",
      "updated_at": "2025-08-18T01:18:44.761Z",
      "reply_count": 1,
      "url": "https://research.kas.pa/t/zoom-in-a-formal-backbone-model-for-the-vprog-computation-dag/407/3",
      "category_id": 11
    },
    {
      "post_id": 644,
      "post_number": 4,
      "topic_id": 407,
      "topic_title": "Zoom-in: A formal backbone model for the vProg computation DAG",
      "topic_slug": "zoom-in-a-formal-backbone-model-for-the-vprog-computation-dag",
      "content": "Why is michaelsutton: At time t, a witness was provided to B_{t-1}, so txns x_{t-2}, x_{t-3} were not executed by p (despite entering its past). Why did x_{t-2} enter the past of p?",
      "raw_content": "",
      "author": "hashdag",
      "created_at": "2025-08-17T19:04:43.343Z",
      "updated_at": "2025-08-17T19:04:43.343Z",
      "reply_count": 1,
      "url": "https://research.kas.pa/t/zoom-in-a-formal-backbone-model-for-the-vprog-computation-dag/407/4",
      "category_id": 11
    },
    {
      "post_id": 645,
      "post_number": 5,
      "topic_id": 407,
      "topic_title": "Zoom-in: A formal backbone model for the vProg computation DAG",
      "topic_slug": "zoom-in-a-formal-backbone-model-for-the-vprog-computation-dag",
      "content": "hashdag: Why did x_{t-2} enter the past of p? Edited to clarify the point.",
      "raw_content": "",
      "author": "michaelsutton",
      "created_at": "2025-08-17T19:27:49.673Z",
      "updated_at": "2025-08-18T01:19:55.766Z",
      "reply_count": 0,
      "url": "https://research.kas.pa/t/zoom-in-a-formal-backbone-model-for-the-vprog-computation-dag/407/5",
      "category_id": 11
    },
    {
      "post_id": 639,
      "post_number": 4,
      "topic_id": 387,
      "topic_title": "Concrete proposal for a synchronously composable verifiable programs architecture",
      "topic_slug": "concrete-proposal-for-a-synchronously-composable-verifiable-programs-architecture",
      "content": "This proposal offers a strong foundation for synchronous composability in L1, but it needs clarification on risk mitigation mechanisms for lost or corrupted witness data, as well as cross-vProg interoperability standards that guarantee security across different VMs. Furthermore, the gas fee-sharing model should be tested through real-world economic simulations to avoid creating negative incentives like spam transactions or state bloat.",
      "raw_content": "",
      "author": "Mitama_Anegokoji",
      "created_at": "2025-08-17T07:11:16.261Z",
      "updated_at": "2025-08-17T07:11:16.261Z",
      "reply_count": 0,
      "url": "https://research.kas.pa/t/concrete-proposal-for-a-synchronously-composable-verifiable-programs-architecture/387/4",
      "category_id": 11
    }
  ],
  "metadata": {
    "forums_processed": 1,
    "total_posts_fetched": 6,
    "credential_status": "configured",
    "processing_mode": "topic_centric"
  }
}